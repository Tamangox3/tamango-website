---
import MiamiLoading from "./miami-loading.astro";
---

<div
  class="fixed top-0 bottom-0 left-0 right-0 md:relative w-screen h-dvh flex flex-col items-center antialiased"
>
  <section class="w-full h-full flex flex-col items-center justify-center">
    <div
      class="relative h-dvh md:aspect-[9/16] md:rounded-[42px] md:h-[90svh] md:drop-shadow-xl md:overflow-hidden"
    >
      <!-- Loading section -->
      <div
        id="loading"
        class="fixed inset-0 bg-black z-50 transition-opacity duration-300 ease-in-out"
      >
        <MiamiLoading />
      </div>

      <!-- Canvas -->
      <div id="video-container">
        <video
          id="video"
          class="h-dvh w-dvw object-cover md:h-full md:w-full md:object-contain"
          no-controls
          muted
          playsinline></video>
        <video
          id="reverse-video"
          no-controls
          muted
          playsinline
          style="display: none;"></video>
      </div>

      <!-- Debug stuff -->
      <div
        class="flex flex-row items-center justify-center absolute bottom-0 right-0 left-0 p-4"
      >
        <span>Scroll speed: <span id="scroll-velocity">0</span></span>
      </div>
    </div>
  </section>
</div>

<script>
  import { AudioManager } from "@lib/miami/audio";
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  import { Observer } from "gsap/Observer";
  import { createMiamiLogger } from "@lib/miami/logger";
  import Hls from "hls.js";

  const VIDEO_ROOT = "https://miami-bucket.tamango.co/v1/playlist.m3u8";
  const VIDEO_ROOT_REVERSE =
    "https://miami-bucket.tamango.co/v1-reverse/playlist.m3u8";

  gsap.registerPlugin(ScrollTrigger, Observer);

  const logger = createMiamiLogger("Main");
  const scrollVelocityEl = document.getElementById("scroll-velocity");
  const videoTag = document.getElementById("video") as HTMLVideoElement | null;
  const reverseVideoTag = document.getElementById(
    "reverse-video"
  ) as HTMLVideoElement | null;
  const container = document.getElementById("video-container");
  const startedLoadingAt = Date.now();
  const audioManager = new AudioManager();
  let triggered = false;
  let isPlaying = false;
  let isReverse = false;

  let speed: number = 1;
  let lastTime: number;

  // prevent default touch move (for mobile, scroll won't refresh page)
  document.addEventListener(
    "touchmove",
    (e) => {
      e.preventDefault();
    },
    { passive: false }
  );

  // pause audio + animation on blur
  window.addEventListener("blur", () => {
    audioManager.pause();
    videoTag?.pause();
    reverseVideoTag?.pause();
  });

  window.addEventListener("focus", () => {
    if (triggered) {
      audioManager.play(audioManager.getBufferOffset());
      if (isReverse) {
        reverseVideoTag?.play();
      } else {
        videoTag?.play();
      }
    }
  });

  // pause audio + animation on visibility change
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      audioManager.pause();

      videoTag?.pause();
      reverseVideoTag?.pause();
    } else {
      if (triggered) {
        audioManager.play(audioManager.getBufferOffset());
        if (isReverse) {
          reverseVideoTag?.play();
        } else {
          videoTag?.play();
        }
      }
    }
  });

  async function sleep(ms: number) {
    return new Promise<void>((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
  }

  async function loadingDone() {
    const loading = document.getElementById("loading");
    if (!loading) return;
    document.getElementById("caricamento")?.remove();
    const btn = document.getElementById(
      "vai-animazione"
    ) as HTMLButtonElement | null;
    if (!btn) {
      logger.error("Button not found");
      return;
    }
    btn.style.display = "block";
    return new Promise<void>((resolve) => {
      btn.addEventListener("click", async () => {
        // Hide loading div by using transform one step at a time
        loading.style.setProperty(
          "transform",
          "rotate(10deg) translateY(-20%)"
        );
        await sleep(300);
        loading.style.setProperty(
          "transform",
          "rotate(-8deg) translateY(-40%)"
        );
        await sleep(300);
        loading.style.setProperty("transform", "rotate(5deg) translateY(-60%)");
        await sleep(300);
        loading.remove();
        resolve();
      });
    });
  }

  function updateSpeed(newSpeed: number) {
    // Clamp the absolute value but preserve sign
    const sign = Math.sign(newSpeed);
    const absSpeed = Math.abs(newSpeed);
    const clampedAbsSpeed = Math.max(0.1, Math.min(absSpeed, 16)); // needs to cap at 16 otherwise browser complains
    newSpeed = sign * clampedAbsSpeed;

    // Update global speed variables
    speed = newSpeed;

    const label = document.querySelector(`label[for="progress-bar"]`);
    if (label) label.textContent = `${newSpeed.toFixed(2)}x`;

    // Update velocity display
    if (scrollVelocityEl) {
      scrollVelocityEl.textContent = newSpeed.toFixed(2);
    }

    // Update audio playback
    audioManager.setPlaybackRate(newSpeed);
    audioManager.setPlaybackRate(newSpeed);

    if (videoTag && reverseVideoTag) {
      if (newSpeed >= 0) {
        if (isReverse) {
          isReverse = false;
          const currentTimeStamp = reverseVideoTag.currentTime;
          logger.log(
            "REVERSE --> FORWARD: Current time stamp",
            currentTimeStamp
          );
          const newTimeStamp = reverseVideoTag.duration - currentTimeStamp;
          videoTag.currentTime = newTimeStamp;

          reverseVideoTag.style.display = "none";
          videoTag.style.display = "block";
          videoTag.addEventListener(
            "seeked",
            () => {
              videoTag.play();
            },
            { once: true }
          );
          logger.log("New time stamp: FORWARD", currentTimeStamp);
        }

        videoTag.playbackRate = newSpeed;
      } else {
        if (!isReverse) {
          isReverse = true;
          const currentTimeStamp = videoTag.currentTime;
          logger.log(
            "FORWARD --> REVERSE: Current time stamp",
            currentTimeStamp
          );
          const newTimeStamp = videoTag.duration - currentTimeStamp;
          logger.log("New time stamp: REVERSE", newTimeStamp);
          reverseVideoTag.currentTime = newTimeStamp;
          reverseVideoTag.style.display = "block";
          videoTag.style.display = "none";
          reverseVideoTag.addEventListener(
            "seeked",
            () => {
              reverseVideoTag.play();
            },
            { once: true }
          );
        }

        reverseVideoTag.playbackRate = -newSpeed;
      }
    }
  }

  async function videoCanStart() {
    const now = Date.now();
    if (now - startedLoadingAt < 4000) {
      await new Promise<void>((resolve) => {
        setTimeout(
          () => {
            resolve();
          },
          4000 - (now - startedLoadingAt)
        );
      });
    }
    if (videoTag && reverseVideoTag) {
      await loadingDone();
      audioManager.play();
      videoTag.play();
      triggered = true;
      isPlaying = true;
    }
  }

  function setupGSAP() {
    gsap.utils.toArray(container).forEach((element) => {
      let startY: number;
      let isDragging = false;
      let velocityTween: any;
      let volumeTween: any;
      let distortionTween: any;
      let wheelTimeout: number | null = null; // For debouncing wheel events
      const mobileRatio = 1;
      const desktopRatio = 5;
      let wasPausedByPress = false;
      let pressTimeout: number | null = null;

      Observer.create({
        target: element as HTMLElement,
        type: "pointer",
        onPress: (self) => {
          logger.log("User pressed the pointer", self);
          if (velocityTween) velocityTween.kill();
          if (wheelTimeout) clearTimeout(wheelTimeout);

          startY = self.y ?? 0;
          isDragging = true;

          if (triggered) {
            audioManager.pause();
            videoTag?.pause();
            reverseVideoTag?.pause();
          }
        },
        onRelease: () => {
          logger.log("User released the pointer");
          if (triggered) {
            isPlaying = true;
            audioManager.play();
            if (isReverse) {
              reverseVideoTag?.play();
            } else {
              videoTag?.play();
            }
          }
        },
      });

      Observer.create({
        target: element as HTMLElement,
        type: "touch,wheel,scroll",
        onPress: (self) => {
          logger.log("Press started at:", self.y);
          if (velocityTween) velocityTween.kill();
          if (wheelTimeout) clearTimeout(wheelTimeout);

          startY = self.y ?? 0;
          logger.log("Press started at:", startY);

          // Reset the flag
          wasPausedByPress = false;

          // Set a timeout to detect a press without dragging
          pressTimeout = window.setTimeout(() => {
            logger.log("User just pressed down");
            audioManager.pause();
            videoTag?.pause();
            isPlaying = false;
            wasPausedByPress = true;
          }, 100);
        },
        onDrag: (self) => {
          logger.log("Drag event detected", self);
          if (pressTimeout) {
            clearTimeout(pressTimeout);
            pressTimeout = null;
          }

          if (wasPausedByPress) {
            logger.log(
              "Skipping speed update because the animation was paused by press."
            );
            return;
          }

          if (!isDragging) {
            isDragging = true;
          }

          const currentY = self.y ?? 0;
          const deltaY = currentY - startY;
          let newSpeed = deltaY / mobileRatio;
          newSpeed = -newSpeed;
          updateSpeed(newSpeed);
          startY = currentY;
        },
        onRelease: () => {
          logger.log("User released the drag");
          if (pressTimeout) {
            clearTimeout(pressTimeout);
            pressTimeout = null;
          }
          if (triggered) {
            if (isDragging) {
              isDragging = false;
            }

            audioManager.play();
            videoTag?.play();
            isPlaying = true;
            animateToNormalSpeed();
          }
        },
        onWheel: (self) => {
          logger.log("Wheel event detected", self);
          if (velocityTween) velocityTween.kill();
          if (wheelTimeout) clearTimeout(wheelTimeout);

          const newSpeed = self.deltaY / desktopRatio;
          updateSpeed(newSpeed);

          wheelTimeout = window.setTimeout(() => {
            animateToNormalSpeed();
          }, 150);
        },
      });

      function animateToNormalSpeed() {
        velocityTween = gsap.to(
          {
            speed: speed,
          },
          {
            speed: 1,
            duration: 1.3,
            ease: "power1.out",
            onUpdate: function () {
              const newSpeed = this.targets()[0].speed;
              updateSpeed(newSpeed);
            },
          }
        );

        volumeTween = gsap.fromTo(
          audioManager,
          {
            volume: 0.3,
          },
          {
            volume: 1,
            duration: 1.3,
            ease: "power1.out",
            onUpdate: function () {
              const newVolume = this.targets()[0].volume;
              audioManager.setVolume(newVolume);
            },
          }
        );
      }
    });
  }

  async function loadAudio() {
    await audioManager.loadAudio("/miami/audio/audio_seq_started.mp3");
  }

  if (videoTag && reverseVideoTag) {
    setupGSAP();
    await loadAudio();

    if (Hls.isSupported()) {
      var hls = new Hls();
      hls.loadSource(VIDEO_ROOT);
      hls.attachMedia(videoTag);
      hls.on(Hls.Events.MANIFEST_PARSED, videoCanStart);

      const hlsReverse = new Hls();
      hlsReverse.loadSource(VIDEO_ROOT_REVERSE);
      hlsReverse.attachMedia(reverseVideoTag);
      hlsReverse.on(Hls.Events.MANIFEST_PARSED, videoCanStart);
    } else if (videoTag.canPlayType("application/vnd.apple.mpegurl")) {
      videoTag.src = VIDEO_ROOT;
      videoTag.addEventListener("canplay", videoCanStart);

      reverseVideoTag.src = VIDEO_ROOT_REVERSE;
      reverseVideoTag.addEventListener("canplay", videoCanStart);
    }

    // if playing, check for drifts every 4 seconds
    setInterval(() => {
      if (isPlaying) {
        logger.log("Checking for drifts");
        const videoTime = videoTag?.currentTime;
        const audioTime = audioManager.getCurrentTime();
        const drift = Math.abs(videoTime - audioTime);

        if (drift > 0.25 && !isReverse) {
          // Threshold of 250ms drift
          logger.log(`Drift detected: ${drift.toFixed(3)}s`);
          // Adjust video time to match audio
          videoTag.currentTime = audioTime;
        }
      }
    }, 4000);
  }
</script>

<style lang="scss">
  html,
  body {
    overscroll-behavior: none; /* Prevents scroll chaining and overscrolling */
    user-select: none;
  }
</style>
