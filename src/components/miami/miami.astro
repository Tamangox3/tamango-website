---
import MiamiLoading from "./miami-loading.astro";
---

<!-- Loading section -->
<div
  id="loading"
  class="fixed inset-0 bg-black z-50 transition-opacity duration-300 ease-in-out"
>
  <MiamiLoading />
</div>

<!-- Canvas -->
<div id="video-container">
  <video id="video" no-controls muted playsinline></video>
</div>

<!-- Debug stuff -->
<div
  class="miami-slider fixed z-10 top-0 left-0 pointer-events-none"
  style="user-select: none;"
>
  <div class="flex flex-col gap-[2px] text-sm m-[2px]">
    <span>Scroll speed: <span id="scroll-velocity">0</span></span>
  </div>
</div>

<script>
  import { AudioManager } from "@lib/miami/audio";
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  import { Observer } from "gsap/Observer";
  import { createMiamiLogger } from "@lib/miami/logger";
  import Hls from "hls.js";

  const VIDEO_ROOT = "https://miami-bucket.tamango.co/v1/playlist.m3u8";

  gsap.registerPlugin(ScrollTrigger, Observer);

  const logger = createMiamiLogger("Main");
  const scrollVelocityEl = document.getElementById("scroll-velocity");
  const videoTag = document.getElementById("video") as HTMLVideoElement | null;
  const container = document.getElementById("video-container");
  const startedLoadingAt = Date.now();
  const audioManager = new AudioManager();
  let triggered = false;
  let isPlaying = false;
  let speed: number = 1;
  let lastTime: number;

  // prevent default touch move (for mobile, scroll won't refresh page)
  document.addEventListener(
    "touchmove",
    (e) => {
      e.preventDefault();
    },
    { passive: false }
  );

  // pause audio + animation on blur
  window.addEventListener("blur", () => {
    audioManager.pause();
    videoTag?.pause();
  });

  window.addEventListener("focus", () => {
    if (triggered) {
      audioManager.play(audioManager.getBufferOffset());
      videoTag?.play();
    }
  });

  // pause audio + animation on visibility change
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      audioManager.pause();
      videoTag?.pause();
    } else {
      if (triggered) {
        audioManager.play(audioManager.getBufferOffset());
        videoTag?.play();
      }
    }
  });

  async function sleep(ms: number) {
    return new Promise<void>((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
  }

  async function loadingDone() {
    const loading = document.getElementById("loading");
    if (!loading) return;
    // Hide loading div by using transform one step at a time
    loading.style.setProperty("transform", "rotate(10deg) translateY(-20%)");
    await sleep(800);
    loading.style.setProperty("transform", "rotate(-8deg) translateY(-40%)");
    await sleep(800);
    loading.style.setProperty("transform", "rotate(5deg) translateY(-60%)");
    await sleep(800);
    loading.remove();
  }

  function updateSpeed(newSpeed: number) {
    // Clamp the absolute value but preserve sign
    const sign = Math.sign(newSpeed);
    const absSpeed = Math.abs(newSpeed);
    const clampedAbsSpeed = Math.max(0.1, Math.min(absSpeed, 16)); // needs to cap at 16 otherwise browser complains
    newSpeed = sign * clampedAbsSpeed;

    // Update global speed variables
    speed = newSpeed;

    const label = document.querySelector(`label[for="progress-bar"]`);
    if (label) label.textContent = `${newSpeed.toFixed(2)}x`;

    // Update velocity display
    if (scrollVelocityEl) {
      scrollVelocityEl.textContent = newSpeed.toFixed(2);
    }

    // Update audio playback
    audioManager.setPlaybackRate(newSpeed);
    if (videoTag) {
      if (newSpeed >= 0) {
        videoTag.playbackRate = newSpeed;
      } else {
        videoTag.playbackRate = 1;
      }
    }
  }

  async function videoCanStart() {
    const now = Date.now();
    if (now - startedLoadingAt < 4000) {
      await new Promise<void>((resolve) => {
        setTimeout(
          () => {
            resolve();
          },
          4000 - (now - startedLoadingAt)
        );
      });
    }
    if (videoTag) {
      await loadingDone();
      audioManager.play();
      videoTag.play();
      triggered = true;
      isPlaying = true;
    }
  }

  function setupGSAP() {
    gsap.utils.toArray(container).forEach((element) => {
      let startY: number;
      let isDragging = false;
      let velocityTween: any;
      let volumeTween: any;
      let distortionTween: any;
      let wheelTimeout: number | null = null; // For debouncing wheel events
      const mobileRatio = 1;
      const desktopRatio = 5;
      let wasPausedByPress = false;
      let pressTimeout: number | null = null;

      Observer.create({
        target: element as HTMLElement,
        type: "pointer",
        onPress: (self) => {
          if (velocityTween) velocityTween.kill();
          if (wheelTimeout) clearTimeout(wheelTimeout);

          startY = self.y ?? 0;
          isDragging = true;

          if (triggered) {
            audioManager.pause();
            videoTag?.pause();
          }
        },
        onRelease: (self) => {
          if (triggered) {
            isPlaying = true;
            audioManager.play();
            videoTag?.play();
          }
        },
      });

      Observer.create({
        target: element as HTMLElement,
        type: "touch,wheel,scroll",
        onPress: (self) => {
          if (velocityTween) velocityTween.kill();
          if (wheelTimeout) clearTimeout(wheelTimeout);

          startY = self.y ?? 0;
          logger.log("Press started at:", startY);

          // Reset the flag
          wasPausedByPress = false;

          // Set a timeout to detect a press without dragging
          pressTimeout = window.setTimeout(() => {
            logger.log("User just pressed down");
            audioManager.pause();
            isPlaying = false;
            wasPausedByPress = true;
          }, 100);
        },

        onDrag: (self) => {
          if (pressTimeout) {
            clearTimeout(pressTimeout);
            pressTimeout = null;
          }

          if (wasPausedByPress) {
            logger.log(
              "Skipping speed update because the animation was paused by press."
            );
            return;
          }

          if (!isDragging) {
            isDragging = true;
          }

          logger.log("User is dragging");
          const currentY = self.y ?? 0;
          const deltaY = currentY - startY;
          let newSpeed = deltaY / mobileRatio;
          newSpeed = -newSpeed;
          updateSpeed(newSpeed);
          startY = currentY;
        },
        onRelease: () => {
          if (pressTimeout) {
            clearTimeout(pressTimeout);
            pressTimeout = null;
          }
          if (triggered) {
            if (isDragging) {
              isDragging = false;
            }

            audioManager.play();
            animateToNormalSpeed();
            isPlaying = true;
          }
        },
        onWheel: (self) => {
          if (velocityTween) velocityTween.kill();
          if (wheelTimeout) clearTimeout(wheelTimeout);

          const newSpeed = self.deltaY / desktopRatio;
          updateSpeed(newSpeed);

          wheelTimeout = window.setTimeout(() => {
            animateToNormalSpeed();
          }, 150);
        },
      });

      function animateToNormalSpeed() {
        velocityTween = gsap.to(
          {
            speed: speed,
          },
          {
            speed: 1,
            duration: 1.3,
            ease: "power1.out",
            onUpdate: function () {
              const newSpeed = this.targets()[0].speed;
              updateSpeed(newSpeed);
              // updateAudioVolume(newSpeed);
            },
          }
        );

        volumeTween = gsap.fromTo(
          audioManager,
          {
            volume: 0.3,
          },
          {
            volume: 1,
            duration: 1.3,
            ease: "power1.out",
            onUpdate: function () {
              const newVolume = this.targets()[0].volume;
              audioManager.setVolume(newVolume);
            },
          }
        );
      }
    });
  }

  async function loadAudio() {
    await audioManager.loadAudio("/miami/audio/audio_seq_started.mp3");
  }

  if (videoTag) {
    setupGSAP();
    await loadAudio();

    if (Hls.isSupported()) {
      var hls = new Hls();
      hls.loadSource(VIDEO_ROOT);
      hls.attachMedia(videoTag);
      hls.on(Hls.Events.MANIFEST_PARSED, videoCanStart);
      hls.on;
    } else if (videoTag.canPlayType("application/vnd.apple.mpegurl")) {
      videoTag.src = VIDEO_ROOT;
      videoTag.addEventListener("canplay", videoCanStart);
    }

    // if playing, check for drifts every 4 seconds
    setInterval(() => {
      if (isPlaying) {
        logger.log("Checking for drifts");
        const videoTime = videoTag?.currentTime;
        const audioTime = audioManager.getCurrentTime();
        const drift = Math.abs(videoTime - audioTime);

        if (drift > 0.1) {
          // Threshold of 100ms drift
          logger.log(`Drift detected: ${drift.toFixed(3)}s`);
          // Adjust video time to match audio
          videoTag.currentTime = audioTime;
        }
      }
    }, 1000);
  }
</script>

<style lang="scss">
  html,
  body {
    overscroll-behavior: none; /* Prevents scroll chaining and overscrolling */
  }

  #video-container {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    & video {
      max-width: min(720px, 100%);
      max-height: min(1280px, 100vh);
      margin: auto;
    }
  }
</style>
