<!-- html components -->

<canvas data-trigger data-animation-canvas class="h-dvh w-dvw"></canvas>


<div class="miami-slider fixed z-10 bottom-[48px] right-[16px] w-[200px] p-3 h-[220px] accent-white rounded-lg flex flex-col items-center space-y-2">
  <div class="flex flex-row items-center gap-2">
    <input
      type="range"
      min={-30}
      max={30}
      step={0.1}
      value={1}
      id="progress-bar"
      aria-orientation="vertical"
    />
    <label for="progress-bar" class="text-white text-sm">1x</label>
  </div>
  <div class="flex flex-col items-center gap-2">

    <span class="text-white text-sm">Scroll speed</span>
    <div id="scroll-velocity" class="text-white text-sm">0</div>
    <span class="text-white text-sm">Audio</span>
    <div id="audio-progress" class="text-white text-sm">00:00</div>
    <div id="audio-percentage" class="text-white text-sm">00%</div>
    <!-- <div id="current-animation-name" class="text-white text-sm">SEQ_started</div> -->
    <span class="text-white text-sm">Animation</span>
    <div id="frame-progress" class="text-white text-sm">00:00</div>
    <!-- <div id="frame-percentage" class="text-white text-sm">0%</div> -->
  </div>
  <button id="reset-button" class="bg-blue-500 hover:bg-blue-700 text-white text-xs font-bold py-1 px-2 rounded">
    Reset speed
  </button>
</div>

<!-- script section -->

<script>

// imports
import RuntimeLoader from "@lib/miami/rive-runtime-loader";
import {
    type StateMachineInstance,
    type RiveCanvas as RiveCanvasType,
    type File as RiveFileType,
  } from "@rive-app/canvas-advanced";
import type { LinearAnimationInstance } from "@rive-app/canvas/rive_advanced.mjs";
import { gsap } from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import { Observer } from "gsap/Observer";

gsap.registerPlugin(ScrollTrigger, Observer);

// utils

const isDev = import.meta.env.MODE === "development";

const logger = {
  log: (...args: unknown[]) => {
    if (isDev) {
      console.log(...args);
    }
  },
};

function formatTime(seconds: number): string {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

// constants
const ANIMATION_DURATION = 150; // animation duration in seconds
const AUDIO_DURATION = 150; // audio duration in seconds
const SYNC_RATIO = ANIMATION_DURATION / AUDIO_DURATION;


// variables

// html elements

const canvas = document.querySelector("[data-animation-canvas]");
const scrollVelocityEl = document.getElementById("scroll-velocity");
const audioProgressEl = document.getElementById("audio-progress");
const audioPercentageEl = document.getElementById("audio-percentage");
const frameProgressEl = document.getElementById("frame-progress");
const resetButtonEl = document.getElementById("reset-button");

// audio context
const audioContext = new AudioContext();
const gainNode = audioContext.createGain();
let audioBuffer: AudioBuffer | null = null;
let reversedAudioBuffer: AudioBuffer | null = null;
let currentSource: AudioBufferSourceNode | null = null;
let isPlaying = false;
let lastSpeed = 1;
let audioStartTime = 0;
let lastPlaybackPosition = 0;
const MAX_PLAYBACK_RATE = 30;
const MIN_PLAYBACK_RATE = 0.001;


// global speed
let speed: number = 1;
let lastTime: number;


// animation context

let activeAnimation: LinearAnimationInstance | null = null;
let idleAnimation: LinearAnimationInstance | null = null;
let stateMachine: StateMachineInstance | null = null;
let rive: RiveCanvasType | null = null;

// initial animation trigger
let triggered = false;





// prevent default touch move (for mobile, scroll won't refresh page)
document.addEventListener('touchmove', (e) => {
  e.preventDefault();
}, { passive: false });

document.getElementById("progress-bar")?.addEventListener("input", (e) => {
  const newSpeed = parseFloat((e.target as HTMLInputElement).value);
  const label = document.querySelector(`label[for="progress-bar"]`);
  if (label) label.textContent = `${newSpeed}x`;
  
  const currentPosition = getCurrentPlaybackPosition();
  playAudio(newSpeed, currentPosition);
  
  speed = newSpeed;
  lastSpeed = newSpeed;
});

document.getElementById("reset-button")?.addEventListener("click", () => {
  const currentPosition = getCurrentPlaybackPosition();
  speed = 1;
  lastSpeed = 1;
  const slider = document.getElementById("progress-bar") as HTMLInputElement;
  if (slider) slider.value = "1";
  const label = document.querySelector(`label[for="progress-bar"]`);
  if (label) label.textContent = "1x";
  playAudio(1, currentPosition);
});


// audio init and update functions

// Load and decode audio file
async function loadAudio() {
  const response = await fetch('/traccia_trim.mp3');
  const arrayBuffer = await response.arrayBuffer();
  audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
  
  // Create reversed buffer
  const { numberOfChannels, length, sampleRate } = audioBuffer;
  reversedAudioBuffer = audioContext.createBuffer(
    numberOfChannels,
    length,
    sampleRate
  );
  
  for (let channel = 0; channel < numberOfChannels; ++channel) {
    const reversedSamples = audioBuffer.getChannelData(channel).slice().reverse();
    reversedAudioBuffer.copyToChannel(reversedSamples, channel);
  }
}


function getCurrentPlaybackPosition() {
  if (!audioBuffer || !isPlaying) return lastPlaybackPosition;
  
  const elapsedTime = audioContext.currentTime - audioStartTime;
  const position = lastPlaybackPosition + (elapsedTime * lastSpeed);
  
  return Math.min(Math.max(0, position), audioBuffer.duration);
}


function updateProgressDisplays(audioPosition: number, activeAnimation: any) {
    // Update audio progress
    if (audioBuffer) {
      const audioDuration = audioBuffer.duration;
      const audioProgressEl = document.getElementById('audio-progress');
      const audioPercentageEl = document.getElementById('audio-percentage');
      const scrollVelocityEl = document.getElementById('scroll-velocity');
      
      if (audioProgressEl) {
        audioProgressEl.textContent = formatTime(audioPosition);
      }
      if (audioPercentageEl) {
        const percentage = Math.round((audioPosition / audioDuration) * 100);
        audioPercentageEl.textContent = `${percentage}%`;
      }
    }


    // Update animation progress
    const frameProgressEl = document.getElementById('frame-progress');
    // const framePercentageEl = document.getElementById('frame-percentage');
    
    if (frameProgressEl) {
      frameProgressEl.textContent = `${formatTime(activeAnimation.time)}`;
    }
    // if (framePercentageEl) {
    //   const percentage = Math.round((activeAnimation.time / activeAnimation.duration) * 100);
    //   framePercentageEl.textContent = `${percentage}%`;
    // }
  }


// =============== Animation Setup Functions ===============
function setupCanvas() {
  // canvas = document.querySelector("[data-animation-canvas]") as HTMLCanvasElement | null;
  if (!canvas) throw new Error("Canvas not found");

  function computeSize() {
    if (!canvas) return;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  window.onresize = computeSize;
  computeSize();

  // return canvas;
}

async function setupRive(canvas: HTMLCanvasElement) {
  const rive = (await RuntimeLoader.awaitInstance()) as RiveCanvasType;
  const fileBytes = new Uint8Array(
    await (await fetch("/miami/miami_v3/r.riv")).arrayBuffer()
  );
  const file = (await rive.load(fileBytes)) as RiveFileType;
  const renderer = rive.makeRenderer(canvas);

  if (isDev) rive.enableFPSCounter();

  return { rive, file, renderer };
}

function setupAnimations(rive: RiveCanvasType, file: RiveFileType) {
  const artboard = file.artboardByName(file.defaultArtboard().name);
  const stateMachine = new rive.StateMachineInstance(
    artboard.stateMachineByIndex(0),
    artboard
  );
  idleAnimation = new rive.LinearAnimationInstance(
    artboard.animationByIndex(0),
    artboard
  );
  activeAnimation = new rive.LinearAnimationInstance(
    artboard.animationByIndex(1),
    artboard
  );

  return { artboard, stateMachine, idleAnimation };
}

function createDrawLoop(
  rive: RiveCanvasType,
  renderer: any,
  artboard: any,
  stateMachine: any,
  canvas: HTMLCanvasElement
) {
  function draw(time: number) {
    if (!lastTime) lastTime = time;
    
    const currentAudioPosition = getCurrentPlaybackPosition();
    const animationPosition = (currentAudioPosition * SYNC_RATIO) % ANIMATION_DURATION;
    
    renderer.clear();
    
    if (activeAnimation) {
      activeAnimation.time = animationPosition;
    }
    
    const elapsedSeconds = (time - lastTime) / 1000;
    lastTime = time;
    
    artboard.advance(elapsedSeconds * speed);
    stateMachine.advance(elapsedSeconds * speed);
    
    renderer.save();
    renderer.align(
      rive.Fit.contain,
      rive.Alignment.center,
      {
        minX: 0,
        minY: 0,
        maxX: canvas?.width ?? window.innerWidth,
        maxY: canvas?.height ?? window.innerHeight,
      },
      artboard.bounds
    );
    artboard.draw(renderer);
    renderer.restore();

    if (activeAnimation) {
      updateProgressDisplays(currentAudioPosition, activeAnimation);
    }

    rive.requestAnimationFrame(draw);
  }

  return draw;
}

async function init() {
  setupCanvas();


  const { rive, file, renderer } = await setupRive(canvas);
  const { artboard, stateMachine } = setupAnimations(rive, file);

  canvas?.addEventListener("click", () => {
    logger.log("status: {triggered: " + triggered + ", isPlaying: " + isPlaying + "}")
    if (!triggered) {
      stateMachine.input(0).asTrigger().fire();
      triggered = true;
      isPlaying = true;
      lastPlaybackPosition = 0;
      playAudio(speed);
      if (activeAnimation) {
        activeAnimation.time = 0;
      }
    }
  });
  
  const drawLoop = createDrawLoop(rive, renderer, artboard, stateMachine, canvas);
  rive.requestAnimationFrame(drawLoop);

  return rive;
}

function playAudio(speed: number, startFromPosition?: number) {
    if (!audioBuffer || !isPlaying) return;

    if (currentSource && isPlaying) {
      lastPlaybackPosition = getCurrentPlaybackPosition();
      currentSource.stop();
      currentSource.disconnect();
    }

    currentSource = audioContext.createBufferSource();
    currentSource.connect(gainNode);
    
    const useReversedBuffer = speed < 0;
    currentSource.buffer = useReversedBuffer ? reversedAudioBuffer : audioBuffer;
    
    const clampedRate = Math.max(MIN_PLAYBACK_RATE, Math.min(Math.abs(speed), MAX_PLAYBACK_RATE));
    currentSource.playbackRate.value = clampedRate;
    
    const gainValue = Math.min(1, Math.max(0.3, 1 - (Math.abs(speed) - 1) * 0.2));
    gainNode.gain.setValueAtTime(gainValue, audioContext.currentTime);
    
    currentSource.loop = true;
    
    if (isPlaying) {
      const position = startFromPosition !== undefined ? startFromPosition : lastPlaybackPosition;
      
      const adjustedPosition = useReversedBuffer ? 
        audioBuffer.duration - position : 
        position;
      
      audioStartTime = audioContext.currentTime;
      currentSource.start(0, adjustedPosition);
      lastPlaybackPosition = position;
      
      // Sync animation position with audio
      activeAnimation.time = (position * SYNC_RATIO) % ANIMATION_DURATION;
    }
  }



// gsap.utils.toArray(canvas).forEach(element => {
//   let startY;
//   let isDragging = false;
//   // Store the current tween to kill it if needed
//   let velocityTween;

//   Observer.create({
//     target: element,
//     type: "touch,wheel,pointer,scroll",
//     onPress: (self) => {
//       // Kill any existing tween when user starts interacting
//       if (velocityTween) velocityTween.kill();
      
//       startY = self.y;
//       isDragging = true;
//       logger.log("Press started at:", startY);
//     },
//     onDrag: (self) => {
//       if (!isDragging) return;
      
//       const currentY = self.y;
//       const deltaY = currentY - startY;
//       const velocity = Math.abs(deltaY) / 100;
      
//       logger.log("Drag velocity:", velocity);
//       if (scrollVelocityEl) {
//         scrollVelocityEl.textContent = velocity.toFixed(2);
//       }
      
//       startY = currentY;
//     },
//     onRelease: () => {
//       isDragging = false;
//       logger.log("Released");
      
//       // Animate back to 1
//       velocityTween = gsap.to({
//         value: parseFloat(scrollVelocityEl.textContent)
//       }, {
//         value: 1,
//         duration: 0.8,
//         ease: "power2.out",
//         onUpdate: function() {
//           if (scrollVelocityEl) {
//             scrollVelocityEl.textContent = this.targets()[0].value.toFixed(2);
//           }
//         }
//       });
//     },
//     onClick: () => logger.log("Clicked"),
//     onWheel: (self) => {
//       // Kill any existing tween on wheel
//       if (velocityTween) velocityTween.kill();
      
//       const velocity = Math.abs(self.deltaY) / 100;
//       logger.log("Wheel velocity:", velocity);
//       if (scrollVelocityEl) {
//         scrollVelocityEl.textContent = velocity.toFixed(2);
//       }
//     }
//   });
// });

// Helper function to update speed and UI consistently
function updateSpeed(newSpeed) {
  // Clamp the absolute value but preserve sign
  const sign = Math.sign(newSpeed);
  const absSpeed = Math.abs(newSpeed);
  const clampedAbsSpeed = Math.max(0.1, Math.min(absSpeed, 30));
  newSpeed = sign * clampedAbsSpeed;
  
  // Update global speed variables
  speed = newSpeed;
  lastSpeed = newSpeed;
  
  // Update slider and label
  const slider = document.getElementById("progress-bar");
  if (slider) slider.value = newSpeed.toString();
  const label = document.querySelector(`label[for="progress-bar"]`);
  if (label) label.textContent = `${newSpeed.toFixed(2)}x`;
  
  // Update velocity display
  if (scrollVelocityEl) {
    scrollVelocityEl.textContent = newSpeed.toFixed(2);
  }
  
  // Update audio playback
  const currentPosition = getCurrentPlaybackPosition();
  playAudio(newSpeed, currentPosition);
}

// need two approaches, one for mobile and one for desktop
// for mobile higher sensitivity (divide by 15)
// for desktop lower sensitivity (divide by 5)

// desktop: wheel debounce (150ms)
// mobile: release is immediate, use tween to animate back to normal speed

gsap.utils.toArray(canvas).forEach(element => {
  let startY;
  let isDragging = false;
  let velocityTween;
  let wheelTimeout: number | null = null;  // For debouncing wheel events

  Observer.create({
    target: element,
    type: "touch,wheel,pointer,scroll",
    onPress: (self) => {
      if (velocityTween) velocityTween.kill();
      if (wheelTimeout) clearTimeout(wheelTimeout);
      
      startY = self.y;
      isDragging = true;
      logger.log("Press started at:", startY);
    },
    onDrag: (self) => {
      if (!isDragging) return;
      
      const currentY = self.y;
      const deltaY = currentY - startY;
      let newSpeed = deltaY / 5;
      newSpeed = -newSpeed;
      
      updateSpeed(newSpeed);
      startY = currentY;
    },
    onRelease: () => {
      isDragging = false;
      logger.log("Released, current speed:", speed);
      
      animateToNormalSpeed();
    },
    onClick: () => logger.log("Clicked"),
    onWheel: (self) => {
      if (velocityTween) velocityTween.kill();
      if (wheelTimeout) clearTimeout(wheelTimeout);
      
      const newSpeed = self.deltaY / 15;
      updateSpeed(newSpeed);

      // Set timeout to trigger release behavior after wheel stops
      wheelTimeout = window.setTimeout(() => {
        animateToNormalSpeed();
      }, 150); // Adjust this delay as needed (150ms works well for most cases)
    }
  });

  // Helper function to animate speed back to normal
  function animateToNormalSpeed() {
    velocityTween = gsap.to({
      speed: speed
    }, {
      speed: 1,
      duration: 1.5,
      ease: "power2.out",
      onUpdate: function() {
        const newSpeed = this.targets()[0].speed;
        updateSpeed(newSpeed);
      }
    });
  }
});


gainNode.connect(audioContext.destination);
await loadAudio();
await init();




</script>

<style>
  .miami-slider > input[type="range"][aria-orientation="vertical"] {
    writing-mode: vertical-lr;
    direction: rtl;
    appearance: slider-vertical;
    vertical-align: bottom;
    transform: rotate(180deg);
    cursor: pointer;
  }

  #reset-button {
    background-color: #3b82f6;
    color: white;
    padding: 0.25rem 0.5rem;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    font-weight: bold;
    width: 100%;
  }

  #reset-button:hover {
    background-color: #2563eb;
  }
</style>