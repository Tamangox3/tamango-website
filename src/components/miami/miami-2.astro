<div
  id="loading"
  class="fixed inset-0 z-50 items-center justify-center bg-black flex flex-col gap-[24px] transition-opacity duration-300 ease-in-out"
>
  <img src="/logo.svg" class="w-[180px]" />
  <div class="flex flex-col items-center gap-4">
    <span id="animation-label" class="text-white text-2xl"
      >L'animazione sta caricando...</span
    >
    <div id="loading-states" class="flex flex-col items-center gap-1">
      <span id="loading-rive" class="text-white text-sm opacity-50"
        >Loading Rive and assets...</span
      >
      <span id="loading-rive-instance" class="text-white text-sm opacity-50"
        >Loading rive instance...</span
      >
      <span id="loading-file" class="text-white text-sm opacity-50"
        >Loading animation file...</span
      >
      <span id="loading-renderer" class="text-white text-sm opacity-50"
        >Setting up renderer...</span
      >
      <span id="loading-artboard" class="text-white text-sm opacity-50"
        >Loading artboard...</span
      >
      <span id="loading-state-machine" class="text-white text-sm opacity-50"
        >Setting up state machine...</span
      >
      <span id="loading-animations" class="text-white text-sm opacity-50"
        >Loading animations...</span
      >
      <span id="loading-draw" class="text-white text-sm opacity-50"
        >Creating draw loop...</span
      >
      <span id="loading-frame" class="text-white text-sm opacity-50"
        >Requesting first frame...</span
      >
    </div>
    <button
      id="go-to-animation"
      class="bg-white text-black p-2 rounded-lg px-4 opacity-50 relative flex flex-row items-center cursor-not-allowed"
      disabled
    >
      <svg
        id="loading-spinner"
        class="animate-spin-slow -ml-1 mr-3 h-5 w-5 text-black"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle
          class="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          stroke-width="4"></circle>
        <path
          class="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        ></path>
      </svg>Vai all'animazione</button
    >
  </div>
</div>

<!-- html components -->
<div id="animation-canvas">
  <canvas data-trigger data-animation-canvas></canvas>
</div>

<!-- <div
  id="play-pause-button"
  class="fixed z-10 bottom- right-[16px] w-[200px] p-3 h-[220px] accent-white rounded-lg flex flex-col items-center space-y-2"
>
  <div
    id="play-pause-button-icon"
    class="w-10 h-10 border-4 border-black border-t-white rounded-full"
  >
    PLAY
  </div>
</div> -->

<div
  class="miami-slider fixed z-10 bottom-[48px] right-[16px] w-[200px] p-3 h-[220px] accent-white rounded-lg flex flex-col items-center space-y-2 pointer-events-none"
>
  <div class="flex flex-row items-center gap-2"></div>
  <div class="flex flex-col items-center gap-2">
    <span class="text-white text-sm">Scroll speed</span>
    <div id="scroll-velocity" class="text-white text-sm">0</div>
    <span class="text-white text-sm">Audio</span>
    <div id="audio-progress" class="text-white text-sm">00:00</div>
    <span class="text-white text-sm">Animation</span>
    <div id="frame-progress" class="text-white text-sm">00:00</div>
  </div>
</div>

<!-- script section -->

<script>
  // imports
  import { isFunction } from "@lib/utils";
  import RuntimeLoader from "@lib/miami/rive-runtime-loader";
  import { AudioManager } from "@lib/miami/audio";
  import {
    type RiveCanvas as RiveCanvasType,
    type File as RiveFileType,
    type FileAsset,
  } from "@rive-app/canvas-advanced";
  import type { LinearAnimationInstance } from "@rive-app/canvas/rive_advanced.mjs";
  import { loadRiveAsset, RIVE_ASSETS } from "@lib/miami/rive-assets";
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  import { Observer } from "gsap/Observer";

  gsap.registerPlugin(ScrollTrigger, Observer);

  // utils
  const isDev = import.meta.env.MODE === "development";

  const logger = {
    log: (...args: unknown[]) => {
      if (isDev) {
        console.log(...args);
      }
    },
  };

  // variables

  // html elements
  const canvas = document.querySelector(
    "[data-animation-canvas]"
  ) as HTMLCanvasElement;
  const scrollVelocityEl = document.getElementById("scroll-velocity");
  const loadingDiv = document.getElementById("loading");

  // Assets base path
  const ASSETS_BASE_PATH = "/miami/miami_v4/assets_v2/";
  const assets = new Map<string, (() => Promise<Uint8Array>) | Uint8Array>();

  // audio manager
  const audioManager = new AudioManager();
  let triggered = false;
  let isPlaying = false;

  // animation context
  let activeAnimation: LinearAnimationInstance | null = null;
  let idleAnimation: LinearAnimationInstance | null = null;

  // global speed
  let speed: number = 1;
  let lastTime: number;

  // prevent default touch move (for mobile, scroll won't refresh page)
  document.addEventListener(
    "touchmove",
    (e) => {
      e.preventDefault();
    },
    { passive: false }
  );

  // ---------------------------- //

  // pause audio + animation on blur
  window.addEventListener("blur", () => {
    console.log("blur event");
    audioManager.pause();
    isPlaying = false;
  });

  // pause audio + animation on visibility change
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      console.log("visibility change event");
      audioManager.pause();
      isPlaying = false;
    }
  });

  function updateProgressDisplays(audioPosition: number, activeAnimation: any) {
    // Update audio progress
    const audioProgressEl = document.getElementById("audio-progress");

    if (audioProgressEl) {
      audioProgressEl.textContent = audioPosition.toFixed(2);
    }

    // Update animation progress
    const frameProgressEl = document.getElementById("frame-progress");
    if (frameProgressEl) {
      frameProgressEl.textContent = activeAnimation.time.toFixed(2);
    }
  }

  // =============== Animation Setup Functions ===============
  function setupCanvas() {
    if (!canvas) throw new Error("Canvas not found");

    function computeSize() {
      if (!canvas) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.onresize = computeSize;
    computeSize();
  }

  async function setupRive(canvas: HTMLCanvasElement, riveBytes: Uint8Array) {
    const rive = (await RuntimeLoader.awaitInstance()) as RiveCanvasType;

    const loadingRiveInstanceEl = document.getElementById(
      "loading-rive-instance"
    );
    if (loadingRiveInstanceEl) {
      loadingRiveInstanceEl.style.opacity = "1";
    }

    // const file = (await rive.load(riveBytes)) as RiveFileType;

    const loadingFileEl = document.getElementById("loading-file");
    if (loadingFileEl) {
      loadingFileEl.style.opacity = "1";
    }

    const file = (await rive.load(
      riveBytes,
      new rive.CustomFileAssetLoader({
        loadContents: (asset: FileAsset, inBandBytes: any) => {
          if (!asset.isImage) {
            // Ignore non-image assets
            return true;
          }
          const filename = asset.uniqueFilename.split(".")[0];
          if (assets.has(filename)) {
            // if loader is a function, call it, otherwise decode the asset
            const assetLoader = assets.get(filename);
            if (!assetLoader) return false; // Shouldn't happen
            if (isFunction<Promise<Uint8Array>>(assetLoader)) {
              assetLoader().then((data) => {
                asset.decode(data);
              });
            } else if (assetLoader instanceof Uint8Array) {
              asset.decode(assetLoader as Uint8Array);
            } else {
              logger.log("Asset loader is not a function or Uint8Array");
              return false;
            }
            return true;
          }
          return false;
        },
      })
    )) as RiveFileType;

    logger.log("SetupRive --> loaded file");

    // Update loading state for file loaded

    const renderer = rive.makeRenderer(canvas);
    logger.log("SetupRive --> File rendered");
    // const fileBytes = new Uint8Array(
    // await (await fetch("/miami/miami_v4_embedded/r4.riv")).arrayBuffer()
    // );

    // const file = (await rive.load(riveBytes)) as RiveFileType;

    // logger.log("SetupRive --> loaded file")

    // Update loading state for renderer
    const loadingRendererEl = document.getElementById("loading-renderer");
    if (loadingRendererEl) {
      loadingRendererEl.style.opacity = "1";
    }

    if (isDev) rive.enableFPSCounter();

    return { rive, file, renderer };
  }

  function loadingDone() {
    document.getElementById("loading-spinner")?.remove();

    const labelDOM = document.getElementById("animation-label");
    if (labelDOM) labelDOM.textContent = "L'animazione Ã¨ pronta";

    const goButton = document.getElementById("go-to-animation");
    if (!goButton) return;
    goButton.removeAttribute("disabled");
    goButton.style.setProperty("opacity", "1");
    goButton.style.setProperty("cursor", "pointer");
    document
      .getElementById("go-to-animation")
      ?.addEventListener("click", () => {
        loadingDiv?.style.setProperty("opacity", "0");
        setTimeout(() => {
          loadingDiv?.style.setProperty("display", "none");
        }, 300);
      });
  }

  function setupAnimations(rive: RiveCanvasType, file: RiveFileType) {
    const artboard = file.artboardByName(file.defaultArtboard().name);
    logger.log("setupAnimations --> loaded artboard");
    logger.log("Default artboard: ", file.defaultArtboard().name);

    // Update loading state for artboard
    const loadingArtboardEl = document.getElementById("loading-artboard");
    if (loadingArtboardEl) {
      loadingArtboardEl.style.opacity = "1";
    }

    const stateMachine = new rive.StateMachineInstance(
      artboard.stateMachineByIndex(0),
      artboard
    );
    logger.log("setupAnimations --> loaded stateMachine");

    // Update loading state for state machine
    const loadingStateMachineEl = document.getElementById(
      "loading-state-machine"
    );
    if (loadingStateMachineEl) {
      loadingStateMachineEl.style.opacity = "1";
    }

    idleAnimation = new rive.LinearAnimationInstance(
      artboard.animationByIndex(0),
      artboard
    );
    activeAnimation = new rive.LinearAnimationInstance(
      artboard.animationByIndex(1),
      artboard
    );
    logger.log("setupAnimations --> loaded animations");

    // Update loading state for animations
    const loadingAnimationsEl = document.getElementById("loading-animations");
    if (loadingAnimationsEl) {
      loadingAnimationsEl.style.opacity = "1";
    }

    return { artboard, stateMachine, idleAnimation };
  }

  function createDrawLoop(
    rive: RiveCanvasType,
    renderer: any,
    artboard: any,
    stateMachine: any,
    canvas: HTMLCanvasElement
  ) {
    function draw(time: number) {
      if (!lastTime) lastTime = time;

      const currentAudioPosition = audioManager.getCurrentTime();

      renderer.clear();

      const elapsedSeconds = (time - lastTime) / 1000;
      lastTime = time;

      if (isPlaying || !triggered) {
        artboard.advance(elapsedSeconds * speed);
        stateMachine.advance(elapsedSeconds * speed);
        activeAnimation?.advance(elapsedSeconds * speed);
      }

      renderer.save();
      renderer.align(
        // if mobile, cover, otherwise contain
        document.body.clientWidth < 640 ? rive.Fit.cover : rive.Fit.contain,
        rive.Alignment.center,
        {
          minX: 0,
          minY: 0,
          maxX: canvas?.width ?? window.innerWidth,
          maxY: canvas?.height ?? window.innerHeight,
        },
        artboard.bounds
      );
      artboard.draw(renderer);
      renderer.restore();

      if (activeAnimation) {
        updateProgressDisplays(currentAudioPosition, activeAnimation);
      }

      rive.requestAnimationFrame(draw);
    }

    return draw;
  }

  async function init(riveBytes: Uint8Array) {
    setupCanvas();

    const { rive, file, renderer } = await setupRive(canvas, riveBytes);
    const { artboard, stateMachine } = setupAnimations(rive, file);

    canvas.addEventListener("click", () => {
      logger.log(
        "status: {triggered: " +
          triggered +
          ", isPlaying: " +
          audioManager.getIsPlaying() +
          "}"
      );
      if (!triggered) {
        stateMachine.input(0).asTrigger().fire();
        triggered = true;
        isPlaying = true;
        audioManager.play(0);
        if (activeAnimation) {
          activeAnimation.time = 0;
        }
      }
    });

    logger.log("init --> before createDrawLoop");
    // Update loading state for draw loop creation
    const loadingDrawEl = document.getElementById("loading-draw");
    if (loadingDrawEl) {
      loadingDrawEl.style.opacity = "1";
    }

    const drawLoop = createDrawLoop(
      rive,
      renderer,
      artboard,
      stateMachine,
      canvas
    );
    rive.requestAnimationFrame(drawLoop);

    logger.log("init --> after createDrawLoop");
    // Update loading state for first frame request
    const loadingFrameEl = document.getElementById("loading-frame");
    if (loadingFrameEl) {
      loadingFrameEl.style.opacity = "1";
    }

    loadingDone();

    return rive;
  }

  function updateSpeed(newSpeed: number) {
    // Clamp the absolute value but preserve sign
    const sign = Math.sign(newSpeed);
    const absSpeed = Math.abs(newSpeed);
    const clampedAbsSpeed = Math.max(0.1, Math.min(absSpeed, 30));
    newSpeed = sign * clampedAbsSpeed;

    // Update global speed variables
    speed = newSpeed;

    // Update slider and label
    // const slider = document.getElementById("progress-bar") as HTMLInputElement;
    // if (slider) slider.value = newSpeed.toString();
    const label = document.querySelector(`label[for="progress-bar"]`);
    if (label) label.textContent = `${newSpeed.toFixed(2)}x`;

    // Update velocity display
    if (scrollVelocityEl) {
      scrollVelocityEl.textContent = newSpeed.toFixed(2);
    }

    // Update audio playback
    audioManager.setPlaybackRate(newSpeed);
  }

  // need two approaches, one for mobile and one for desktop
  // for mobile higher sensitivity (divide by 15)
  // for desktop lower sensitivity (divide by 5)

  // desktop: wheel debounce (150ms)
  // mobile: release is immediate, use tween to animate back to normal speed

  gsap.utils.toArray(canvas).forEach((element) => {
    let startY: number;
    let isDragging = false;
    let velocityTween: any;
    let volumeTween: any;
    let distortionTween: any;
    let wheelTimeout: number | null = null; // For debouncing wheel events
    const mobileRatio = 1;
    const desktopRatio = 5;

    Observer.create({
      target: element as HTMLElement,
      type: "touch,wheel,pointer,scroll",
      onPress: (self) => {
        if (velocityTween) velocityTween.kill();
        if (wheelTimeout) clearTimeout(wheelTimeout);

        startY = self.y ?? 0;
        isDragging = true;
        logger.log("Press started at:", startY);
      },
      onDrag: (self) => {
        if (!isDragging) return;

        const currentY = self.y ?? 0;
        const deltaY = currentY - startY;
        let newSpeed = deltaY / mobileRatio;
        newSpeed = -newSpeed;
        updateSpeed(newSpeed);
        startY = currentY;
      },
      onRelease: () => {
        isDragging = false;
        logger.log("Released, current speed:", speed);
        // updateSpeed(1);
        animateToNormalSpeed();
      },
      onClick: () => {
        logger.log("Clicked");
        if (isPlaying) {
          audioManager.pause();
          isPlaying = false;
        } else {
          audioManager.play(audioManager.getBufferOffset());
          isPlaying = true;
        }
      },
      onWheel: (self) => {
        if (velocityTween) velocityTween.kill();
        if (wheelTimeout) clearTimeout(wheelTimeout);

        const newSpeed = self.deltaY / desktopRatio;
        updateSpeed(newSpeed);

        wheelTimeout = window.setTimeout(() => {
          animateToNormalSpeed();
        }, 150);
      },
    });

    function animateToNormalSpeed() {
      velocityTween = gsap.to(
        {
          speed: speed,
        },
        {
          speed: 1,
          duration: 2,
          ease: "power2.out",
          onUpdate: function () {
            const newSpeed = this.targets()[0].speed;
            updateSpeed(newSpeed);
            // updateAudioVolume(newSpeed);
          },
        }
      );

      volumeTween = gsap.fromTo(
        audioManager,
        {
          volume: 0.3,
        },
        {
          volume: 1,
          duration: 2,
          ease: "power2.out",
          onUpdate: function () {
            const newVolume = this.targets()[0].volume;
            audioManager.setVolume(newVolume);
          },
        }
      );
    }
  });

  // Load rive, audio and first sequence assets
  async function loadAssets() {
    const firstSeqAssets = RIVE_ASSETS.filter((asset) =>
      asset.startsWith("SEQ1")
    );
    const [riveData] = await Promise.all([
      fetch("/miami/miami_v4/r2.riv").then((res) => res.arrayBuffer()),
      audioManager.loadAudio("/miami/audio/audio_seq_started.mp3"),
      // Ensure that Seq1 assets are loaded before showing the animation
      Promise.allSettled(
        firstSeqAssets.map((asset) => {
          const filename = asset.split(".")[0];
          if (!assets.has(filename)) {
            logger.log(`Asset ${filename} not found`);
            return Promise.resolve();
          }
          return (assets.get(filename) as () => Promise<Uint8Array>)().then(
            (data) => {
              assets.set(filename, data);
            }
          );
        })
      ),
    ]);

    return {
      riveData: new Uint8Array(riveData),
    };
  }

  // Start background loading of assets
  function setupBackgroundAssetsLoading() {
    RIVE_ASSETS.forEach((asset) => {
      const filename = asset.split(".")[0];
      // Store a lazy function that initializes the loading when called
      assets.set(filename, () => loadRiveAsset(ASSETS_BASE_PATH, asset));
    });
  }

  setupBackgroundAssetsLoading();
  const { riveData } = await loadAssets();

  // Update first loading state
  const loadingRiveEl = document.getElementById("loading-rive");
  if (loadingRiveEl) {
    loadingRiveEl.style.opacity = "1";
  }

  await init(riveData);

  // if playing, check for drifts every 4 seconds
  setInterval(() => {
    if (isPlaying) {
      logger.log("Checking for drifts");
      const animationTime = activeAnimation?.time || 0;
      const audioTime = audioManager.getCurrentTime();
      const drift = Math.abs(animationTime - audioTime);

      if (drift > 0.1) {
        // Threshold of 100ms drift
        logger.log(`Drift detected: ${drift.toFixed(3)}s`);
        // Adjust animation time to match audio
        if (activeAnimation) {
          activeAnimation.time = audioTime;
        }
      }
    }
  }, 4000);
</script>

<style>
  #speed-minus-one,
  #speed-one,
  #speed-two {
    background-color: #3b82f6;
    color: white;
    padding: 0.25rem 0.5rem;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    font-weight: bold;
  }

  #speed-minus-one:hover,
  #speed-one:hover,
  #speed-two:hover {
    background-color: #2563eb;
  }
  #animation-canvas {
    aspect-ratio: 9 / 16;
    width: 100dvw;
    height: 100dvh;
  }
</style>
